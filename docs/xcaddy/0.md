
XCaddy[源码](https://sourcegraph.com/github.com/caddyserver/xcaddy)

## XCaddy是什么？

xcaddy的全称是Custom Caddy Builder。简单来说，XCaddy是一个用于定制化编译[Caddy Web Server](https://github.com/caddyserver/caddy)的命令行构建工具。主要是用于caddy的插件打包进caddy。

用过caddy的应该都知道在[下载](https://caddyserver.com/download)caddy的时候会让选择caddy的操作系统及需要的插件。然后caddy官方服务器会根据你的选择即是编译，将选择的插件和caddy本体编译到选定的操作系统格式，最终获得一个单一的二进制程序。xcaddy所能作的工作就是作为这个过程的Builder工具。

## 源码分析

### 输入信息的结构体定义

首先定义一个Builder结构体：

```go
type Builder struct {
	Compile
	CaddyVersion string        `json:"caddy_version,omitempty"`
	Plugins      []Dependency  `json:"plugins,omitempty"`
	Replacements []Replace     `json:"replacements,omitempty"`
	TimeoutGet   time.Duration `json:"timeout_get,omitempty"`
	TimeoutBuild time.Duration `json:"timeout_build,omitempty"`
	RaceDetector bool          `json:"race_detector,omitempty"`
	SkipCleanup  bool          `json:"skip_cleanup,omitempty"`
}
```

其中`Compile`包含编译参数相关的信息：
```go
type Compile struct {
	Platform
	Cgo bool `json:"cgo,omitempty"`
}
```
由此可见主要是平台信息:
```go
type Platform struct {
	OS   string // 操作系统名称
	Arch string // 计算机架构
	ARM  string // arm版本
}
```
`CaddyVersion`用于指定caddy的版本信息

`Plugins`用于指定需要的插件列表：

```go
type Dependency struct {
	PackagePath string // 插件路径
	Version string // 插件版本
}

`Replacements`用于替换插件路径的path（使用golang的应该知道是什么东西，详细的可以`go rename --help`）:

type ReplacementPath string
type Replace struct {
	Old ReplacementPath // import中被替换掉的路径
	New ReplacementPath  // import中用于替换的新路径
}
```
`TimeoutGet`用于指定拉取插件的超时时间
`TimeoutBuild`用于指定构建的超时时间

`RaceDetector`:用于指定是否开启detector

`SkipCleanUp`:用于指定是否cleanup

将上面所有的字段都展开一下，Builder包含下面的配置字段信息:

+ OS :操作系统
+ Arch :计算机架构
+ ARM  : arm版本
+ Cgo : 是否开启cgo
+ CaddyVersion ：caddy版本
+ Plugins :插件信息列表[（插件1路径，插件1版本),（插件2路径，插件2版本)]
+ Replacements ：路径替换列表[(old1->new1),(old2->new2)]
+ TimeoutGet  ：插件代码拉取超时时间
+ TimeoutBuild: 构建超时时间
+ RaceDetector：是否开启Detector
+ SkipCleanup:是否跳过CleanUp

这也是构建工作所需要的最多输入配置信息。

### 可用方法

作为构建器的结构体有以下方法：

+ `Build(ctx context.Context, outputFile string) error`
  + 按照config配置构建生成caddy二进制文件
+ ``

### 完整的逻辑流程

## 学到了什么


xcaddy本身并没用到什么特殊的技术，就是一个简单的构建流程脚本。但如果日后我们需要编写自己的Builder工具，xcaddy仍有可借鉴的技巧：


对于一个常见的Builde工具

1. 首先定义Builder Struct，清晰看出所需的数据P
2. Builder Struct实现绑定的方法
3. Builder Struct各部分分解为独立的struct,各部分struct实现各自需要的方法
4. 在cli-main中rake整个build流程
